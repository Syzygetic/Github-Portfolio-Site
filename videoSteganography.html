<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Video Steganography — In-browser (LSB RGB)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <style>
    body { background:#f0f8ff; color:#333; }
    .navbar { background:#e0f0ff; }
    .card { border-radius:1rem; box-shadow:0 4px 10px rgba(0,0,0,0.05); }
    .btn-primary { background:#5dade2; border-color:#5dade2; }
    .btn-primary:hover { background:#3498db; }
    #progressContainer { display:none; margin-top:1rem; }
    #statusText { white-space:pre-line; }
    canvas { max-width:100%; }
  </style>
</head>
<body>
<nav class="navbar navbar-expand-lg mb-4">
  <div class="container-fluid">
    <a class="navbar-brand fw-bold" href="index.html">MySite</a>
  </div>
</nav>

<div class="container">
  <h1 class="text-center mb-4">Video Steganography (LSB RGB, in-browser)</h1>

  <div class="card p-4 mb-4">
    <div class="mb-3">
      <label class="form-label">Upload Video</label>
      <input id="videoInput" type="file" class="form-control" accept="video/*">
    </div>

    <div class="row g-2 mb-3">
      <div class="col-md-9">
        <label class="form-label">Secret message to hide</label>
        <textarea id="secretMessage" rows="3" class="form-control"></textarea>
      </div>
      <div class="col-md-3">
        <label class="form-label">BitRange (bits / channel)</label>
        <select id="bitRange" class="form-select">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4" selected>4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
        </select>
        <div class="small text-muted mt-2">Total bits/pixel = bitRange × 3</div>
      </div>
    </div>

    <div class="d-flex gap-2">
      <button id="encodeBtn" class="btn btn-primary" disabled>Encode Message</button>
      <button id="cancelBtn" class="btn btn-secondary" disabled>Cancel</button>
      <div id="capacityInfo" class="ms-3 align-self-center small text-muted"></div>
    </div>

    <div id="progressContainer" class="mt-3">
      <div class="progress">
        <div id="progressBar" class="progress-bar" role="progressbar" style="width:0%">0%</div>
      </div>
      <div id="statusText" class="mt-2"></div>
    </div>
  </div>

  <div id="previewArea" class="text-center" style="display:none;">
    <h5>Preview (first frame)</h5>
    <canvas id="frameCanvas" style="border:1px solid #ddd;"></canvas>
  </div>
</div>

<script type="module">
import { FFmpeg } from './assets/ffmpeg/umd/ffmpeg.js';

const videoInput = document.getElementById('videoInput');
const secretMessage = document.getElementById('secretMessage');
const bitRangeSelect = document.getElementById('bitRange');
const encodeBtn = document.getElementById('encodeBtn');
const cancelBtn = document.getElementById('cancelBtn');
const capacityInfo = document.getElementById('capacityInfo');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');
const statusText = document.getElementById('statusText');
const previewArea = document.getElementById('previewArea');
const frameCanvas = document.getElementById('frameCanvas');
const ctx = frameCanvas.getContext('2d');

const ffmpeg = new FFmpeg({
  log:true,
  corePath:'./assets/ffmpeg/ffmpeg-core.wasm',
  workerPath:'./assets/ffmpeg/esm/worker.js'
});

let canceled = false;

// Helpers
function pad(n,d=5){ return String(n).padStart(d,'0'); }
function messageToBinary(msg){ return (msg+'=====').split('').map(c=>c.charCodeAt(0).toString(2).padStart(8,'0')).join(''); }
function writeBitsToChannel(val,bits,bitRange){
  if(bits.length<bitRange) bits+='0'.repeat(bitRange-bits.length);
  const bin = val.toString(2).padStart(8,'0');
  const newBin = bin.slice(0,8-bitRange)+bits;
  return { newVal: parseInt(newBin,2), consumed: bits.length };
}

async function loadFFmpeg(){
  statusText.textContent='Loading FFmpeg...';
  await ffmpeg.load({ classWorkerURL:'./assets/ffmpeg/esm/worker.js' });
  statusText.textContent='FFmpeg loaded.';
}

async function generatePreview(file){
  statusText.textContent=''; capacityInfo.textContent=''; previewArea.style.display='none';
  await loadFFmpeg();
  await ffmpeg.writeFile('input.mp4', new Uint8Array(await file.arrayBuffer()));

  await ffmpeg.run('-i','input.mp4','-ss','00:00:00','-frames:v','1','f000.png');
  const f0 = ffmpeg.FS('readFile','f000.png');
  const imgBlob = new Blob([f0.buffer], {type:'image/png'});
  const img = new Image();
  await new Promise((res,rej)=>{
    img.onload=res;
    img.onerror=rej;
    img.src=URL.createObjectURL(imgBlob);
  });

  frameCanvas.width=img.width; frameCanvas.height=img.height;
  ctx.drawImage(img,0,0);
  previewArea.style.display='block';

  const bitRange = parseInt(bitRangeSelect.value,10);
  const bitsPerFrame = img.width*img.height*3*bitRange;
  capacityInfo.textContent = `Resolution ${img.width}×${img.height} | est frame capacity ≈ ${Math.floor(bitsPerFrame/8)} bytes`;
}

async function encodeSteg(file, message){
  canceled = false;
  cancelBtn.disabled = false;
  encodeBtn.disabled = true;
  progressContainer.style.display = 'block';
  progressBar.style.width = '0%';
  progressBar.textContent = '0%';
  statusText.textContent = 'Preparing...';

  try {
    await loadFFmpeg();
    const data = new Uint8Array(await file.arrayBuffer());
    await ffmpeg.writeFile('input.mp4', data);

    // --- probe video ---
    statusText.textContent = 'Probing video metadata...';
    const probe = await ffmpeg.ffprobe('input.mp4');
    const dm = probe.streams?.find(s => s.codec_type === 'video');
    const duration = parseFloat(probe.format.duration) || 1;
    const fpsRaw = dm ? dm.avg_frame_rate.split('/') : [25, 1];
    const fps = Math.max(1, Math.round(parseFloat(fpsRaw[0])/parseFloat(fpsRaw[1] || 1)));
    const totalFrames = Math.max(1, Math.round(duration * fps));

    statusText.textContent = `Duration: ${duration.toFixed(2)}s, FPS: ${fps}, Total frames: ${totalFrames}`;

    const bitRange = parseInt(bitRangeSelect.value, 10);
    const binary = messageToBinary(message);

    // Extract all frames
    statusText.textContent = 'Extracting frames...';
    await ffmpeg.run('-i','input.mp4','-vf',`fps=${fps}`,'frame%05d.png');

    // Extract audio
    statusText.textContent = 'Extracting audio...';
    await ffmpeg.run('-i','input.mp4','-vn','-c:a','aac','audio.aac');

    const bitsPerFrame = 0; // will calculate per frame
    let bitIndex = 0;

    statusText.textContent = 'Embedding message into frames...';
    for (let i = 0; i < totalFrames; i++) {
      if (canceled) throw new Error('Encoding canceled');

      const fname = `frame${pad(i)}.png`;
      if (!ffmpeg.FS('readdir','./').includes(fname)) break; // safety

      const fdata = ffmpeg.FS('readFile', fname);
      const blob = new Blob([fdata.buffer], { type:'image/png' });
      const img = new Image();
      await new Promise((res,rej)=>{
        img.onload = () => { URL.revokeObjectURL(img.src); res(); };
        img.onerror = rej;
        img.src = URL.createObjectURL(blob);
      });

      frameCanvas.width = img.width; frameCanvas.height = img.height;
      ctx.drawImage(img,0,0);

      const imageData = ctx.getImageData(0,0,frameCanvas.width,frameCanvas.height);
      const dataArr = imageData.data;

      for(let p=0; p<dataArr.length && bitIndex<binary.length; p+=4){
        for(let c=0; c<3 && bitIndex<binary.length; c++){
          const chunk = binary.slice(bitIndex, bitIndex+bitRange);
          const { newVal, consumed } = writeBitsToChannel(dataArr[p+c], chunk, bitRange);
          dataArr[p+c] = newVal;
          bitIndex += consumed;
        }
      }
      ctx.putImageData(imageData,0,0);

      const canvasBlob = await new Promise(r=>frameCanvas.toBlob(r,'image/png'));
      const ab = await canvasBlob.arrayBuffer();
      await ffmpeg.writeFile(fname, new Uint8Array(ab));

      const percent = Math.round(((i+1)/totalFrames)*100);
      progressBar.style.width = percent + '%';
      progressBar.textContent = `${percent}% (${i+1}/${totalFrames})`;

      if (bitIndex >= binary.length) break; // stop if message fully embedded
    }

    statusText.textContent = 'Re-encoding video with audio...';
    await ffmpeg.run(
      '-framerate', String(fps),
      '-i', 'frame%05d.png',
      '-i', 'audio.aac',
      '-c:v', 'libx264', '-pix_fmt', 'yuv420p',
      '-c:a', 'aac',
      'stego_output.mp4'
    );

    const out = ffmpeg.FS('readFile', 'stego_output.mp4');
    const outBlob = new Blob([out.buffer], { type:'video/mp4' });
    const url = URL.createObjectURL(outBlob);
    const a = document.createElement('a');
    a.href = url; a.download = 'stego_encoded_video.mp4';
    a.textContent = 'Download encoded video';
    a.className = 'btn btn-success mt-2';
    statusText.textContent = 'Encoding complete — download below.';
    statusText.appendChild(document.createElement('br'));
    statusText.appendChild(a);
    progressBar.style.width='100%';
    progressBar.textContent='100%';

  } catch(err){
    console.error(err);
    statusText.textContent = 'Error: ' + (err?.message || String(err));
  } finally {
    encodeBtn.disabled = false;
    cancelBtn.disabled = true;
  }
}

// Event handlers
videoInput.addEventListener('change', async ()=>{
  capacityInfo.textContent=''; statusText.textContent=''; progressContainer.style.display='none'; encodeBtn.disabled=true;
  try{
    const file=videoInput.files[0]; if(!file) return;
    await generatePreview(file);
    encodeBtn.disabled=false;
  }catch(e){ console.error(e); statusText.textContent='Preview failed: '+(e.message||e); }
});

encodeBtn.addEventListener('click', async ()=>{
  const file=videoInput.files[0]; const msg=secretMessage.value||'';
  if(!file){ alert('Select a video'); return; }
  if(!msg){ alert('Type a secret message'); return; }
  await encodeSteg(file,msg);
});
</script>
</body>
</html>
