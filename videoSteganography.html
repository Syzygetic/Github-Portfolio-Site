<script>
async function encodeVideo() {
  try {
    encodeBtn.disabled = true;
    statusText.textContent = "Preparing video...";
    progressBar.style.width = "0%";
    progressBar.textContent = "0%";

    const secret = secretMessage.value.trim();
    if (!secret) {
      alert("Please enter a secret message.");
      encodeBtn.disabled = false;
      return;
    }

    const videoFile = videoInput.files[0];
    if (!videoFile) {
      alert("Please select a video file.");
      encodeBtn.disabled = false;
      return;
    }

    await loadFFmpeg();

    // Write the input video to FFmpeg FS
    const arrayBuffer = await videoFile.arrayBuffer();
    await ffmpeg.writeFile("input.mp4", new Uint8Array(arrayBuffer));

    let totalFrames = null;
    let durationSeconds = null;

    // Hook to FFmpeg logs to update progress
    ffmpeg.on("log", (message) => {
      // Parse duration (once)
      if (!durationSeconds) {
        const durationMatch = message.match(/Duration:\s(\d+):(\d+):([\d.]+)/);
        if (durationMatch) {
          const hours = parseInt(durationMatch[1]);
          const mins = parseInt(durationMatch[2]);
          const secs = parseFloat(durationMatch[3]);
          durationSeconds = hours * 3600 + mins * 60 + secs;
        }
      }

      // Parse fps to calculate total frames
      if (!totalFrames) {
        const fpsMatch = message.match(/, (\d+(?:\.\d+)?) fps,/);
        if (fpsMatch && durationSeconds) {
          const fps = parseFloat(fpsMatch[1]);
          totalFrames = Math.round(fps * durationSeconds);
        }
      }

      // Parse current frame to update progress
      const frameMatch = message.match(/frame=\s*(\d+)/);
      if (frameMatch && frameMatch[1]) {
        const frame = parseInt(frameMatch[1]);
        let percent = 0;

        if (totalFrames) {
          percent = Math.min(Math.round((frame / totalFrames) * 100), 100);
          statusText.textContent = `Encoding frame ${frame} / ${totalFrames}`;
        } else {
          statusText.textContent = `Encoding frame ${frame} / ?`;
        }

        progressBar.style.width = percent + "%";
        progressBar.textContent = percent + "%";
      }
    });

    // Run your encoding command (example: re-encode with H.264)
    await ffmpeg.exec([
      "-i", "input.mp4",
      "-c:v", "libx264",
      "-preset", "fast",
      "-crf", "23",
      "output.mp4"
    ]);

    // Read the result
    const outputData = await ffmpeg.readFile("output.mp4");
    const blob = new Blob([outputData.buffer], { type: "video/mp4" });
    const url = URL.createObjectURL(blob);

    statusText.textContent = "Encoding complete!";
    progressBar.style.width = "100%";
    progressBar.textContent = "100%";

    // Download link
    const link = document.createElement("a");
    link.href = url;
    link.download = "encoded_video.mp4";
    link.textContent = "Download Encoded Video";
    document.body.appendChild(link);

  } catch (err) {
    console.error("Encoding error:", err);
    alert("Encoding failed: " + err.message);
  } finally {
    encodeBtn.disabled = false;
  }
}
</script>
