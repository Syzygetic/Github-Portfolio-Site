<script>
(async function(){
  const videoInput = document.getElementById('videoInput');
  const secretMessage = document.getElementById('secretMessage');
  const bitRangeSelect = document.getElementById('bitRange');
  const encodeBtn = document.getElementById('encodeBtn');
  const cancelBtn = document.getElementById('cancelBtn');
  const capacityInfo = document.getElementById('capacityInfo');
  const progressContainer = document.getElementById('progressContainer');
  const progressBar = document.getElementById('progressBar');
  const statusText = document.getElementById('statusText');
  const previewArea = document.getElementById('previewArea');
  const frameCanvas = document.getElementById('frameCanvas');
  const ctx = frameCanvas.getContext('2d');

  const ffmpeg = new FFmpegWASM.FFmpeg({
    log: true,
    corePath: './assets/ffmpeg/ffmpeg-core.wasm',
    workerPath: './assets/ffmpeg/esm/worker.js'
  });

  let canceled = false;
  let ffmpegLoaded = false;

  cancelBtn.addEventListener('click', () => {
    canceled = true;
    statusText.textContent = 'Cancel requested — terminating ffmpeg...';
    try { ffmpeg.terminate(); } catch(e){ console.warn('terminate failed', e); }
    cancelBtn.disabled = true;
  });

  async function loadFFmpeg() {
    if (!ffmpegLoaded) {
      statusText.textContent = 'Loading FFmpeg-wasm...';
      await ffmpeg.load();
      ffmpegLoaded = true;
      statusText.textContent = 'FFmpeg loaded.';
    }
  }

  function pad(n,digits=5){ return String(n).padStart(digits,'0'); }
  function messageToBinary(msg){ return (msg+'=====').split('').map(c=>c.charCodeAt(0).toString(2).padStart(8,'0')).join(''); }
  function writeBitsToChannel(channelVal,bits,bitRange){ 
    const origLen = bits.length;
    if(bits.length<bitRange) bits += '0'.repeat(bitRange-bits.length);
    const bin = channelVal.toString(2).padStart(8,'0');
    const newBin = bin.slice(0, 8-bitRange) + bits;
    return { newVal: parseInt(newBin,2), consumed: origLen };
  }

  async function probeVideoInfo() {
    let probeLog = '';
    const onLog = (m)=>{ if(typeof m==='string') probeLog+=m+'\n'; else if(m?.message) probeLog+=m.message+'\n'; };
    ffmpeg.on('log', onLog);
    try { await ffmpeg.exec(['-i','input.mp4']); } catch(e){}
    try { ffmpeg.off && ffmpeg.off('log', onLog); } catch(e){}
    let duration=0,fps=null;
    const dm = probeLog.match(/Duration:\s*(\d+):(\d+):([\d.]+)/);
    if(dm) duration=+dm[1]*3600 + +dm[2]*60 + +dm[3];
    const lines = probeLog.split(/\r?\n/);
    for(const L of lines){
      if(/Stream.*Video/.test(L)){
        const fm=L.match(/(\d+(?:\.\d+)?)\s*fps/);
        if(fm){ fps=+fm[1]; break; }
      }
    }
    if(!fps){
      const rm = probeLog.match(/r_frame_rate[:=]\s*([\d\/]+)/) || probeLog.match(/avg_frame_rate[:=]\s*([\d\/]+)/);
      if(rm){ const [num,den]=rm[1].split('/').map(Number); if(den) fps=num/den; }
    }
    if(!fps||!isFinite(fps)) fps=25;
    return {duration,fps};
  }

  async function generatePreviewAndEstimate(file){
    statusText.textContent='';
    capacityInfo.textContent='';
    previewArea.style.display='none';
    await loadFFmpeg();
    const ab = await file.arrayBuffer();
    await ffmpeg.writeFile('input.mp4', new Uint8Array(ab));
    statusText.textContent='Probing video metadata...';
    const {duration,fps}=await probeVideoInfo();
    const fpsUsed=Math.max(1,Math.floor(fps));
    await ffmpeg.exec(['-i','input.mp4','-ss','00:00:00','-frames:v','1','f000.png']);
    const f0 = await ffmpeg.readFile('f000.png');
    const imgBlob = new Blob([f0.buffer],{type:'image/png'});
    const img = new Image();
    await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; img.src=URL.createObjectURL(imgBlob); });
    frameCanvas.width=img.width; frameCanvas.height=img.height;
    ctx.drawImage(img,0,0);
    previewArea.style.display='block';
    const bitRange=parseInt(bitRangeSelect.value,10);
    const bitsPerFrame=img.width*img.height*3*bitRange;
    const estFrames=Math.max(1,Math.round(duration*fpsUsed));
    const totalCapacityBits=bitsPerFrame*estFrames;
    capacityInfo.textContent=`Resolution ${img.width}×${img.height} | est frames ${estFrames} | capacity ≈ ${Math.floor(totalCapacityBits/8)} bytes (${totalCapacityBits} bits)`;
    statusText.textContent=`Detected duration ${duration.toFixed(2)}s, fps ≈ ${fpsUsed}.`;
  }

  async function extractAllFramesUsingFps(fps) {
    // progressive frame extraction
    await ffmpeg.exec(['-i','input.mp4','-vf',`fps=${fps}`,'frame%05d.png']);
    // count extracted frames
    const files = ffmpeg.FS('readdir','/').filter(f => f.match(/^frame\d+\.png$/));
    return files.length;
  }

  async function encodeSteg(file,message){
    canceled=false;
    cancelBtn.disabled=false;
    encodeBtn.disabled=true;
    progressContainer.style.display='block';
    progressBar.style.width='0%';
    progressBar.textContent='0%';
    statusText.textContent='Preparing...';

    try{
      await loadFFmpeg();
      const arr = await file.arrayBuffer();
      await ffmpeg.writeFile('input.mp4', new Uint8Array(arr));

      statusText.textContent='Probing video info...';
      const {duration,fps}=await probeVideoInfo();
      const fpsUsed=Number.isFinite(fps)?fps:25;

      // extract all frames once
      statusText.textContent='Extracting frames...';
      const totalFrames = await extractAllFramesUsingFps(fpsUsed);
      if(totalFrames<=0) throw new Error('No frames extracted');
      statusText.textContent=`Frames extracted: ${totalFrames}`;

      // convert message to binary
      const binary=messageToBinary(message);
      const bitRange=parseInt(bitRangeSelect.value,10);

      // check capacity
      const firstFrameData = await ffmpeg.readFile(`frame00001.png`);
      const firstBlob = new Blob([firstFrameData.buffer], {type:'image/png'});
      const img = new Image();
      await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; img.src=URL.createObjectURL(firstBlob); });
      frameCanvas.width=img.width; frameCanvas.height=img.height;
      const bitsPerFrame=img.width*img.height*3*bitRange;
      const totalCapacityBits=bitsPerFrame*totalFrames;
      if(binary.length>totalCapacityBits) throw new Error(`Message too large. Capacity ≈ ${Math.floor(totalCapacityBits/8)} bytes, message ${(binary.length/8).toFixed(2)} bytes.`);

      let bitIndex=0;

      for(let i=1;i<=totalFrames;i++){
        if(canceled) throw new Error('Encoding canceled by user');
        const fname = `frame${pad(i)}.png`;
        const fdata = await ffmpeg.readFile(fname);
        const blob = new Blob([fdata.buffer],{type:'image/png'});
        const frameImg = new Image();
        await new Promise((res,rej)=>{
          frameImg.onload=async ()=>{
            frameCanvas.width=frameImg.width;
            frameCanvas.height=frameImg.height;
            ctx.drawImage(frameImg,0,0);

            const imageData=ctx.getImageData(0,0,frameCanvas.width,frameCanvas.height);
            const data=imageData.data;

            for(let p=0;p<data.length && bitIndex<binary.length;p+=4){
              if(bitIndex<binary.length){
                const chunk=binary.slice(bitIndex,bitIndex+bitRange);
                const {newVal,consumed}=writeBitsToChannel(data[p],chunk,bitRange);
                data[p]=newVal; bitIndex+=consumed;
              }
              if(bitIndex<binary.length){
                const chunk=binary.slice(bitIndex,bitIndex+bitRange);
                const {newVal,consumed}=writeBitsToChannel(data[p+1],chunk,bitRange);
                data[p+1]=newVal; bitIndex+=consumed;
              }
              if(bitIndex<binary.length){
                const chunk=binary.slice(bitIndex,bitIndex+bitRange);
                const {newVal,consumed}=writeBitsToChannel(data[p+2],chunk,bitRange);
                data[p+2]=newVal; bitIndex+=consumed;
              }
            }
            ctx.putImageData(imageData,0,0);

            const canvasBlob = await new Promise(r => frameCanvas.toBlob(r,'image/png'));
            const arr = await canvasBlob.arrayBuffer();
            await ffmpeg.writeFile(fname,new Uint8Array(arr));

            // free memory
            ffmpeg.FS('unlink', fname);
            URL.revokeObjectURL(frameImg.src);
            URL.revokeObjectURL(canvasBlob);
            res();
          };
          frameImg.onerror=rej;
          frameImg.src=URL.createObjectURL(blob);
        });

        const percent=Math.round((i/totalFrames)*100);
        progressBar.style.width=percent+'%';
        progressBar.textContent=`${percent}% (${i}/${totalFrames})`;
        statusText.textContent=`Embedding: frame ${i}/${totalFrames} — bits used ${bitIndex}/${binary.length}`;
      }

      statusText.textContent='Re-encoding frames to video...';
      try{ await ffmpeg.exec(['-i','input.mp4','-q:a','0','-map','a','audio.mp3']); } catch(e){}
      await ffmpeg.exec(['-framerate',String(Math.round(fpsUsed)),'-i','frame%05d.png','-c:v','libx264','-pix_fmt','yuv420p','video_no_audio.mp4']);
      try{ await ffmpeg.exec(['-i','video_no_audio.mp4','-i','audio.mp3','-c','copy','stego_output.mp4']); }
      catch(e){ await ffmpeg.exec(['-i','video_no_audio.mp4','-c','copy','stego_output.mp4']); }

      const out = await ffmpeg.readFile('stego_output.mp4');
      const outBlob = new Blob([out.buffer],{type:'video/mp4'});
      const url = URL.createObjectURL(outBlob);
      const a = document.createElement('a');
      a.href=url; a.download='stego_encoded_video.mp4';
      a.textContent='Download encoded video';
      a.className='btn btn-success mt-2';
      statusText.textContent='Encoding complete — download below.';
      statusText.appendChild(document.createElement('br'));
      statusText.appendChild(a);
      progressBar.style.width='100%';
      progressBar.textContent='100%';
    }
    catch(err){
      console.error('Encoding error:',err);
      statusText.textContent='Error: '+(err?.message||String(err));
    }
    finally{
      encodeBtn.disabled=false;
      cancelBtn.disabled=true;
    }
  }

  videoInput.addEventListener('change',async ()=>{
    capacityInfo.textContent='';
    statusText.textContent='';
    progressContainer.style.display='none';
    encodeBtn.disabled=true;
    try{
      const file=videoInput.files[0];
      if(!file) return;
      await generatePreviewAndEstimate(file);
      encodeBtn.disabled=false;
    } catch(e){ console.error(e); statusText.textContent='Preview failed: '+(e.message||e); }
  });

  encodeBtn.addEventListener('click',async ()=>{
    const file = videoInput.files[0];
    const msg = secretMessage.value || '';
    if(!file){ alert('Select a video'); return; }
    if(!msg){ alert('Type a secret message'); return; }
    encodeBtn.disabled=true;
    await encodeSteg(file,msg);
  });

})();
</script>
