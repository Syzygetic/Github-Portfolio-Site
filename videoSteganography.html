<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Video Steganography — In-browser (LSB)</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <style>
    body { background:#f0f8ff; color:#333; }
    .navbar { background:#e0f0ff; }
    .card { border-radius:1rem; box-shadow:0 4px 10px rgba(0,0,0,0.05); }
    .btn-primary { background:#5dade2; border-color:#5dade2; }
    .btn-primary:hover { background:#3498db; }
    #progressContainer { display:none; margin-top:1rem; }
    #statusText { white-space:pre-line; }
    canvas { max-width:100%; }
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg mb-4">
    <div class="container-fluid">
      <a class="navbar-brand fw-bold" href="index.html">MySite</a>
    </div>
  </nav>

  <div class="container">
    <h1 class="text-center mb-4">Video Steganography (LSB, in-browser)</h1>

    <div class="card p-4 mb-4">
      <div class="mb-3">
        <label class="form-label">Upload Video</label>
        <input id="videoInput" type="file" class="form-control" accept="video/*">
      </div>

      <div class="mb-3">
        <label class="form-label">Secret message to hide</label>
        <textarea id="secretMessage" rows="3" class="form-control"></textarea>
      </div>

      <div class="d-flex gap-2">
        <button id="encodeBtn" class="btn btn-primary" disabled>Encode Message (steganography)</button>
        <button id="cancelBtn" class="btn btn-secondary" disabled>Cancel</button>
      </div>

      <div id="progressContainer" class="mt-3">
        <div class="progress">
          <div id="progressBar" class="progress-bar" role="progressbar" style="width:0%">0%</div>
        </div>
        <div id="statusText" class="mt-2"></div>
      </div>
    </div>

    <div id="previewArea" class="text-center" style="display:none;">
      <h5>Preview (first frame)</h5>
      <canvas id="frameCanvas" style="border:1px solid #ddd;"></canvas>
    </div>
  </div>

  <!-- Self-hosted UMD build -->
  <script src="./assets/ffmpeg/umd/ffmpeg.js"></script>
  <script>
  (function(){
    const videoInput = document.getElementById('videoInput');
    const secretMessage = document.getElementById('secretMessage');
    const encodeBtn = document.getElementById('encodeBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const previewArea = document.getElementById('previewArea');
    const frameCanvas = document.getElementById('frameCanvas');
    const ctx = frameCanvas.getContext('2d');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const statusText = document.getElementById('statusText');

    // instantiate (UMD global is FFmpegWASM)
    const ffmpeg = new FFmpegWASM.FFmpeg({
      log: true,
      corePath: './assets/ffmpeg/ffmpeg-core.wasm',
      workerPath: './assets/ffmpeg/esm/worker.js'
    });

    let canceled = false;
    cancelBtn.addEventListener('click', () => {
      canceled = true;
      statusText.textContent = 'Cancel requested — terminating ffmpeg...';
      try { ffmpeg.terminate(); } catch(e){ console.warn('terminate failed', e); }
      cancelBtn.disabled = true;
    });

    async function loadFFmpeg() {
      if (!ffmpeg.loaded) {
        statusText.textContent = 'Loading FFmpeg-wasm (this may take a few seconds)...';
        await ffmpeg.load();
        statusText.textContent = 'FFmpeg loaded.';
      }
    }

    // show preview (first frame)
    async function generatePreview(file) {
      previewArea.style.display = 'none';
      await loadFFmpeg();

      // write input
      const ab = await file.arrayBuffer();
      await ffmpeg.writeFile('input.mp4', new Uint8Array(ab));

      // extract first frame
      await ffmpeg.exec(['-i','input.mp4','-ss','00:00:00','-frames:v','1','preview.png']);
      const pngData = await ffmpeg.readFile('preview.png');
      const blob = new Blob([pngData.buffer], { type: 'image/png' });
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = () => {
          frameCanvas.width = img.width;
          frameCanvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          previewArea.style.display = 'block';
          resolve();
        };
        img.onerror = reject;
        img.src = URL.createObjectURL(blob);
      });
    }

    // convert message to binary string (with delimiter)
    function messageToBinary(msg) {
      // append terminator so decoder knows the end
      const full = msg + '\0'; // null-terminated
      return full.split('').map(ch => ch.charCodeAt(0).toString(2).padStart(8,'0')).join('');
    }

    // embed bits into canvas red-channel LSB, continue from bitIndex, return new bitIndex
    function embedBitsIntoCanvas(canvas, binary, bitIndex) {
      const c = canvas.getContext('2d');
      const imageData = c.getImageData(0,0,canvas.width,canvas.height);
      const data = imageData.data; // RGBA
      const totalBitsAvailable = canvas.width * canvas.height; // using red LSB only (1 bit per pixel)
      let used = 0;
      for (let p = 0; p < data.length && bitIndex < binary.length; p += 4) {
        const bit = +binary[bitIndex];
        data[p] = (data[p] & 0xFE) | bit; // red channel LSB
        bitIndex++;
        used++;
      }
      c.putImageData(imageData, 0, 0);
      return { bitIndex, used, totalBitsAvailable };
    }

    // parse duration and fps by running a bare -i probe and capturing log lines
    async function probeVideoInfo() {
      // clear any old listeners
      let probeLog = '';
      // temporary log listener
      const onLog = (msg) => { if (typeof msg === 'string') probeLog += msg + '\n'; else if (msg && msg.message) probeLog += msg.message + '\n'; };
      ffmpeg.on('log', onLog);

      // run a quick probe that will emit the header info to log
      try {
        await ffmpeg.exec(['-i','input.mp4']);
      } catch (e) {
        // ffmpeg -i usually exits with non-zero because no output specified; still logs info
        // swallow the error; we only needed logs
      } finally {
        // remove listener
        // there's no off() function in some builds; we leave it or override by replacing on('log') later
      }

      // best-effort parse duration
      let duration = null;
      let fps = null;

      // find Duration: HH:MM:SS.xx
      const durMatch = probeLog.match(/Duration:\s*(\d+):(\d+):([\d.]+)/);
      if (durMatch) {
        const h = parseInt(durMatch[1],10);
        const m = parseInt(durMatch[2],10);
        const s = parseFloat(durMatch[3]);
        duration = h*3600 + m*60 + s;
      }

      // find stream line that contains fps or r_frame_rate or avg_frame_rate
      // examples: "Stream #0:0(eng): Video: h264 (High), yuv420p, 1920x1080, 30 fps, 30 tbr, 90k tbn, 60 tbc"
      // or "r_frame_rate: 30000/1001"
      const streamMatches = probeLog.matchAll(/Stream.*Video.*$/gim);
      for (const m of streamMatches) {
        const line = m[0];
        // attempt to find "30 fps" or "25.00 fps"
        const fpsMatch = line.match(/(\d+(?:\.\d+)?)\s*fps/);
        if (fpsMatch) {
          fps = parseFloat(fpsMatch[1]);
          break;
        }
        // attempt to find r_frame_rate or avg_frame_rate elsewhere in the log
      }

      if (!fps) {
        const rMatch = probeLog.match(/r_frame_rate[:=]\s*([\d\/]+)/) || probeLog.match(/avg_frame_rate[:=]\s*([\d\/]+)/);
        if (rMatch && rMatch[1]) {
          const [num, den] = rMatch[1].split('/').map(Number);
          if (den && den !== 0) fps = num / den;
        }
      }

      // fallback defaults
      if (!duration) duration = 0;
      if (!fps || !isFinite(fps)) fps = 25;

      return { duration, fps };
    }

    // pad number for frame file (e.g. 001)
    function pad(n, digits=3) {
      return String(n).padStart(digits,'0');
    }

    // main encode pipeline (per-frame LSB)
    async function encodeSteg(file, message) {
      canceled = false;
      cancelBtn.disabled = false;
      encodeBtn.disabled = true;
      statusText.textContent = 'Preparing...';
      progressContainer.style.display = 'block';
      progressBar.style.width = '0%';
      progressBar.textContent = '0%';

      try {
        await loadFFmpeg();

        // write input to FS
        const arr = await file.arrayBuffer();
        await ffmpeg.writeFile('input.mp4', new Uint8Array(arr));

        // probe for duration & fps by capturing ffmpeg logs
        statusText.textContent = 'Probing video (duration & fps)...';
        const { duration, fps } = await probeVideoInfo();
        if (duration <= 0) {
          statusText.textContent = 'Could not detect duration — aborting';
          throw new Error('Could not detect duration');
        }
        const estimatedTotalFrames = Math.max(1, Math.round(duration * fps));
        statusText.textContent = `Duration: ${duration.toFixed(2)}s, FPS: ${fps.toFixed(2)}, Estimated frames: ${estimatedTotalFrames}`;

        // Prepare binary message and capacity checks
        const binary = messageToBinary(message);
        // We'll embed using red-channel LSB only => bits per frame = width*height (we'll detect per-frame after extracting first frame)
        // Extract first frame to determine dimensions & capacity
        statusText.textContent += '\nExtracting first frame to determine capacity...';
        await ffmpeg.exec(['-i','input.mp4','-ss','00:00:00','-frames:v','1','f000.png']);
        const f0 = await ffmpeg.readFile('f000.png');
        const blob0 = new Blob([f0.buffer], { type:'image/png' });
        const img0 = new Image();
        await new Promise((resolve, reject) => {
          img0.onload = resolve;
          img0.onerror = reject;
          img0.src = URL.createObjectURL(blob0);
        });
        frameCanvas.width = img0.width;
        frameCanvas.height = img0.height;
        ctx.drawImage(img0,0,0);
        const bitsPerFrame = img0.width * img0.height; // 1 bit per pixel (red LSB)
        const totalCapacity = bitsPerFrame * estimatedTotalFrames;
        if (binary.length > totalCapacity) {
          throw new Error(`Message too large. Capacity: ${Math.floor(totalCapacity/8)} bytes, message: ${Math.ceil(binary.length/8)} bytes.`);
        }

        statusText.textContent += `\nCapacity per frame: ${bitsPerFrame} bits, total capacity: ${totalCapacity} bits`;

        // Now loop through frames, extract, embed, and write back
        let bitIndex = 0;
        const totalFrames = estimatedTotalFrames;
        for (let i = 0; i < totalFrames; i++) {
          if (canceled) throw new Error('User canceled');

          const ts = (i / fps).toFixed(3); // timestamp in seconds for frame extraction
          const frameFilename = `frame${pad(i)}.png`;

          // extract frame i
          await ffmpeg.exec(['-i','input.mp4','-ss', ts, '-frames:v','1', frameFilename]);
          const frameData = await ffmpeg.readFile(frameFilename);
          const blob = new Blob([frameData.buffer], { type:'image/png' });

          // load into Image then canvas
          const img = new Image();
          await new Promise((resolve, reject) => {
            img.onload = () => {
              frameCanvas.width = img.width;
              frameCanvas.height = img.height;
              ctx.drawImage(img, 0, 0);

              // embed bits into canvas red LSB
              const res = embedBitsIntoCanvas(frameCanvas, binary, bitIndex);
              bitIndex = res.bitIndex;

              // convert canvas back to PNG and write to FS
              frameCanvas.toBlob(async (canvasBlob) => {
                const ab = await canvasBlob.arrayBuffer();
                await ffmpeg.writeFile(frameFilename, new Uint8Array(ab));
                resolve();
              }, 'image/png');
            };
            img.onerror = reject;
            img.src = URL.createObjectURL(blob);
          });

          // update progress
          const percent = Math.round(((i+1)/totalFrames) * 100);
          progressBar.style.width = percent + '%';
          progressBar.textContent = `${percent}% (${i+1}/${totalFrames})`;
          statusText.textContent = `Embedding: frame ${i+1}/${totalFrames} — bits written ${bitIndex}/${binary.length}`;
        }

        // re-encode frames to video (preserve frame rate)
        statusText.textContent = 'Re-encoding video from modified frames (this may take a while)...';
        // extract audio into a file (if present) so we can merge later
        try {
          await ffmpeg.exec(['-i','input.mp4','-q:a','0','-map','a','audio.mp3']);
        } catch(e) {
          // if no audio stream, ignore
        }

        // Create video from frames
        // Use frame%03d.png pattern; ensure pad matches (we used pad 3)
        await ffmpeg.exec([
          '-framerate', String(Math.round(fps)),
          '-i', 'frame%03d.png',
          '-c:v', 'libx264',
          '-pix_fmt', 'yuv420p',
          'video_no_audio.mp4'
        ]);

        // if audio exists, merge
        try {
          await ffmpeg.exec(['-i','video_no_audio.mp4','-i','audio.mp3','-c','copy','encoded_output.mp4']);
        } catch(e) {
          // fallback to video without audio
          await ffmpeg.exec(['-i','video_no_audio.mp4','-c','copy','encoded_output.mp4']);
        }

        const final = await ffmpeg.readFile('encoded_output.mp4');
        const outBlob = new Blob([final.buffer], { type:'video/mp4' });
        const url = URL.createObjectURL(outBlob);

        // present download link
        const a = document.createElement('a');
        a.href = url;
        a.download = 'stego_encoded_video.mp4';
        a.textContent = 'Download encoded video';
        a.className = 'btn btn-success mt-2';
        statusText.textContent = 'Encoding complete — download below.';
        statusText.appendChild(document.createElement('br'));
        statusText.appendChild(a);

        // done
        progressBar.style.width = '100%';
        progressBar.textContent = '100%';
      }
      catch (err) {
        console.error('Encoding error:', err);
        statusText.textContent = 'Error: ' + (err && err.message ? err.message : String(err));
      }
      finally {
        encodeBtn.disabled = false;
        cancelBtn.disabled = true;
      }
    }

    // events
    videoInput.addEventListener('change', async () => {
      const file = videoInput.files[0];
      if (!file) return;
      encodeBtn.disabled = true;
      statusText.textContent = '';
      progressContainer.style.display = 'none';
      try {
        await generatePreview(file);
        encodeBtn.disabled = false;
      } catch(e) {
        console.error(e);
        statusText.textContent = 'Preview failed: ' + (e.message || e);
      }
    });

    encodeBtn.addEventListener('click', async () => {
      const file = videoInput.files[0];
      const msg = secretMessage.value || '';
      if (!file) { alert('Select a video'); return; }
      if (!msg) { alert('Type a secret message'); return; }
      encodeBtn.disabled = true;
      await encodeSteg(file, msg);
    });

  })();
  </script>
</body>
</html>
